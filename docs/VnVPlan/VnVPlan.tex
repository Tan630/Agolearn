\documentclass[12pt, titlepage]{article}
\setlength{\parindent}{0pt}
\setlength{\parskip}{12pt}
\linespread{1.2}
\usepackage{caption} 
\captionsetup[table]{skip=10pt}
\hfuzz=900.002pt 
\hbadness=99999
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{algorithm2e}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{changepage}
\hypersetup{
colorlinks,
citecolor=blue,
filecolor=black,
linkcolor=red,
urlcolor=blue
}
\usepackage[round]{natbib}

\input{../Comments}
\input{../Common}

\begin{document}

\title{Project Title: System Verification and Validation Plan for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section*{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
  \toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
  \midrule
  2024-02-29 & 1.0 & First Draft\\
  2024-03-11 & 1.1 & Transcription to latex\\
  \bottomrule
\end{tabularx}

~\\

\newpage

\tableofcontents

\listoftables
\wss{Remove this section if it isn't needed}

\listoffigures
\wss{Remove this section if it isn't needed}

\newpage

\section{Symbols, Abbreviations, and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  SRS & Software requirements specification\\
  VNV & Verification and validation\\
  Module guide\\
  MIS & Module interface specification\\
  \bottomrule
\end{tabular}\\

\wss{symbols, abbreviations, or acronyms --- you can simply reference the SRS
\citep{SRS} tables, if appropriate}

\wss{Remove this section if it isn't needed}

\newpage

\pagenumbering{arabic}

This document ... \wss{provide an introductory blurb and roadmap of the
Verification and Validation plan}

\section{Introduction}

\textbf{Verification and validation} (\textbf{VnV}) ensures that the project sufficiently satisfies its requirements. If the project fails to satisfy its requirements, then VnV discusses and documents the extent of this failure.
VnV splits into \textbf{verification} and \textbf{validation}. Verification verifies the soft-ware against a set of requirements; validation considers the necessity and feasibility of requirements.

This section divides into the following subsections:
\begin{enumerate}
  \item \textbf{Objectives} discusses the definition of verification and validation and the purpose of this document
  \item \textbf{Characteristics of Intended Readers}| discusses characteristics required to understand this document
  \item \textbf{Relevant Documentation} lists documents that are referenced in this document.
\end{enumerate}

\subsection{Objectives}
\label{subsec:objectives}
This document is the \textbf{verification and validation plan} (\textbf{VnV plan}), which documents the planning and instructs the implementation of VnV procedures. The VnV plan starts after the requirements stage and before the design stage, then undergoes iterative refinements as development continues.


\subsubsection{Limitations of Testing}
\label{subsubsec:limitations}
Testing cannot ensure correctness, only that the program performs correctly for the tested test cases. Testing only builds confidence that the software is correct. Techniques (such as unit testing) and metrics (such as coverage metrics) improve the effectiveness of tests at building performance.

\subsection{Characteristics of Intended Readers}
\label{subsec:characteristics}
This document is designed for readers with the following roles and characteristics. Readers with these characteristics should be able to understand this document.
\textbf{Developers} design and implement Agolearn test cases following this document. Developers have the following characteristics:
\begin{itemize}
  \item	Understanding of modular testing
  \item	Familiarity with evolutionary learning comparable to a graduate course on evolutionary learning
\end{itemize}

\textbf{Users} consult test cases to understand \thisproject and its capabilities. Users have the following characteristics:

\begin{itemize}
  \item	Understanding of modular software design
  \item	Familiarity with evolutionary learning comparable to a graduate course on evolutionary learning
\end{itemize}

\subsection{Relevant Documentation}
This document references the following documents:
\begin{itemize}
  \item	SRS.pdf: Requirement specifications 
\end{itemize}

\section{Scope of Tests}
This section discusses what tests do and do not cover. This section includes the following subsections:
\begin{enumerate}
  \item \textbf{Assumptions} lists conditions that are assumed to be true by all test cases
  \item \textbf{Ignored Categories} lists conditions that are not tested
  \item \textbf{Machinery} lists machinery that are used to describe test cases
\end{enumerate}
\subsection{Assumptions}
Validation and verification procedures make the following assumptions:
\begin{itemize}
  \item \textbf{Locality}: The library is always available and exists locally. Access to the internet is unavailable.
  \item \textbf{The environment is abstract}: System-dependent resources, such as environment variables and system calls, are not explicitly available.
  \item \textbf{Direct access}: Test primitives can directly invoke the tested interface.
  \item \textbf{Resources are abundant}: Tests can use as much computational re-source as necessary.
  \item 
\end{itemize}

\subsection{Ignored Categories}
The following properties are either infeasible or impossible to test. Measure these properties, but do not write test cases for these measurements.
\begin{itemize}
  \item \textbf{Performance}. The software is not performance sensitive.
\end{itemize}

\subsection{Machinery}
The following subsections describe the machinery of testing.
\begin{enumerate}
  \item \textbf{Constants} are immutable values.
  \item \textbf{Pseudo-Oracles} are reference implementations that behave similarly to Agolearn.
  \item \textbf{Interfaces} lists objects that are used in testing, and describes how to interact with these objects.
  \item \textbf{Primitives} are functions that facilitate the testing process.
\end{enumerate}

\subsubsection{Constants}
The following table describes testing constants in the following types:

\begin{itemize}
  \item \textbf{Ground truths} are constants known before the fact. These constants describe the reality that is captured by the project.
  \item \textbf{Test Constants} are constants only used in test cases.
  \item \textbf{Error Margins} are special test constants that describe the leniency of test cases. A test case passes if the difference is within the given error margin.
\end{itemize}


\begin{table}[!h]
  \caption{Ground Truths}
  \label{table:ground-truths}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule {\bf Symbol} & {\bf Description}\\
    \midrule
    Placeholder & what \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{table}[!h]
  \caption{Test Constants}
  \label{table:test-constants}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule {\bf Symbol} & {\bf Description}\\
    \midrule
    Placeholder & what \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{table}[!h]
  \caption{Error Margins}
  \label{table:error-margins}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule {\bf Symbol} & {\bf Description}\\
    \midrule
    $\delta_{F}$ & Error margin for floating-point comparisons \\
    \bottomrule
  \end{tabularx}
\end{table}

\subsubsection{Pseud-Oracles}
\begin{itemize}
  \item \textbf{Pyvolution}: A modular evolutionary learning framework
\end{itemize}


\subsubsection{Interfaces}
A genome describes a solution representation. The fitness of a genome positively correlates to its suitability as a solution.

\begin{table}[!ht]
  \caption{Genome}
  \label{table:genome}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Name} & Genome \\
    \midrule
    {\bf Type} & Data Structure \\
    \midrule
    {\bf Attributes} & {
    \begin{tabularx}{\textwidth}{@{}p{3cm}X}
      $\mathrm{fitness}:\mathrm{Real}$ & Quality of solution\\
    \end{tabularx}}
    \\
    \bottomrule\\
  \end{tabularx}
\end{table}

\begin{table}[!ht]
  \caption{Population Factory}
  \label{table:population-factory}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Name} & population\_factory \\
    \midrule
    {\bf Type} & $\textrm{Set}[\textrm{Genome}]\rightarrow \textrm{Population}$ \\
    
    \bottomrule\\
  \end{tabularx}
\end{table}

\begin{table}[!ht]
  \caption{Population}
  \label{table:population}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Name} & Population \\
    \midrule
    {\bf Type} & Data Structure \\
    \midrule
    {\bf Attributes} & {
    \begin{tabularx}{\textwidth}{@{}p{3cm}X}
      $\mathrm{size}:\mathrm{Int_{\ge 0}}$ & Number of genomes in population\\
    \end{tabularx}}
    \\
    \bottomrule\\
  \end{tabularx}
\end{table}

\todo{Find better names for `arity'}
\begin{table}[!ht]
  \caption{Variator}
  \label{table:variator}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Name} & Variator \\
    \midrule
    {\bf Type} & $\textrm{Population} \rightarrow \textrm{Population}$ \\
    \midrule
    {\bf Attributes} & {
    \begin{tabularx}{\textwidth}{@{}p{3cm}X}
      $\mathrm{arity}:\mathrm{Int_{\ge 0}}$ & Input arity\\
      $\mathrm{coarity}:\mathrm{Int_{\ge 0}}$ & Output arity\\
      $\mathrm{residual}:\mathrm{Int_{\ge 0}}$ & Extra children\\
    \end{tabularx}}
    \\
    \bottomrule\\
  \end{tabularx}
\end{table}

\begin{table}[!ht]
  \caption{Selector}
  \label{table:selector}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Name} & Selector \\
    \midrule
    {\bf Type} & $\textrm{Population} \rightarrow \textrm{Population}$ \\
    \midrule
    {\bf Attributes} & {
    \begin{tabularx}{\textwidth}{@{}p{3cm}X}
      $\mathrm{outsize}:\mathrm{Int_{\ge 0}}$ & Size of the output population
    \end{tabularx}}
    \\
    \bottomrule\\
  \end{tabularx}
\end{table}

\begin{table}[!ht]
  \caption{Evaluator}
  \label{table:evaluator}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Name} & Evaluator \\
    \midrule
    {\bf Type} & $\mathrm{Genome} \rightarrow \mathrm{Real}$ \\
    
    \bottomrule\\
  \end{tabularx}
\end{table}

\subsubsection{Primitives}
The $\mathrm{assert\_epsilon}$ primitive compares floating-point numbers, accounting for floating-point errors.
\begin{algorithm}[H]
  $\mathrm{assert\_ epsilon} : \mathbb{R} \times \mathbb{R} \times \mathbb{R} \rightarrow \{\bot, \top\}$
  
  $\mathrm{assert\_ epsilon}(a,b,\varepsilon)$:
  
  \eIf{$|a-b|<\varepsilon$}{
  \Return {$\top$}
  }{
  \Return {$\bot$}
  }
\end{algorithm}

The type primitive returns the mathematical type of its argument.

\begin{algorithm}[H]
  $\mathrm{type} : \mathrm{Any} \rightarrow \mathrm{Type}$

  $\mathrm{type} (o)$:

  \Return {the type of $o$}
\end{algorithm}

The $\mathrm{best\_fit}$ primitive returns a member of a population with the highest fitness

\newcommand{\argmax}{\mathop{\mathrm{argmax}}}
\begin{algorithm}[H]
  $\mathrm{best\_fit} : \mathrm{Population} \rightarrow \mathrm{Genome}$

  $\mathrm{best\_fit}(G)$:

  \Return {$\argmax_{g\in G}\{g.\mathrm{fitness}\}$}
\end{algorithm}

\subsection{Test Plan}
\subsubsection{Verification and Validation Team}
The VnV team includes verifiers and validators.
\textbf{Verifiers}: The following people review the implementation of this project.

\begin{tabularx}{\textwidth}{p{3cm}X}
  \toprule {\bf Name} & {\bf Role}\\
  \midrule
  Yiding Li & Designer and implementor of test cases \\
  Stephen Kelly & Domain expert and usability reviewer  \\
  \bottomrule
\end{tabularx}

\textbf{Validators}: The following people review design artefacts.

\begin{tabularx}{\textwidth}{p{3cm}X}
  \toprule {\bf Name} & {\bf Role}\\
  \midrule
  Yiding Li&Author of development artefacts\\
  Spencer Smith&Course instructor,  reviewer\\
  Fasil Cheema&Domain expert and primary  reviewer\\
  Fatemah&SRS reviewer\\
  Tanya Djavaherpou&VnV reviewer\\
  Phil Du&MG + MIS reviewer\\
  \bottomrule
\end{tabularx}

\subsection{Test Plan}
This section describes elements that should be tested, and how to test them. These elements are as follows:
\begin{itemize}
  \item \textbf{Conditions}: preconditions, postconditions, and invariants
  \item \textbf{Functional Requirements}: functional requirements sourced from SRS.pdf
  \item \textbf{Nonfunctional Requirements}: nonfunctional requirements sourced from SRS.pdf
  \item \textbf{Coverage}: coverage criteria that should be met by test cases.
  \item \textbf{Traceability} Information: Reference from test cases to requirements.
\end{itemize}

\subsubsection{Conditions}
\textbf{C1}: The size of a population follows its variators.

\begin{table}[!ht]
  \caption{T1: Test Plan for C1}
  \label{table:t1}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Subject} & A variator\\
    {\bf Control} & Manual\\
    {\bf Initial State} & A population $P$ is initialized and available

    A variator $V$ is initialized and available\\
    {\bf Input} & A population $P$\\
    {\bf Output} & A population $P'$ whose size is

    $(P/(V.\mathrm{arity}))\cdot V.\mathrm{coarity}+\mathrm{extra}$\\

    \bottomrule
  \end{tabularx}
\end{table}

\textbf{C2}: The size of a population should adhere to selectors.
\begin{table}[!ht]
  \caption{T2: Test Plan for C2}
  \label{table:t2}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Subject} & A selector\\
    {\bf Control} & Manual\\
    {\bf Initial State} & A population $P$ is initialized and available

    A variator $V$ is initialized and available\\
    {\bf Input} & A population $P$\\
    {\bf Output} & A population $P'$ whose size is

    $\max \{S.\mathrm{outsize},P.\mathrm{size}\}$\\
    \bottomrule
  \end{tabularx}
\end{table}

\subsubsection{Functional Requirements}

\textbf{FR1}: Type check input values
\begin{table}[!ht]
  \caption{T3: Test Plan for FR1}
  \label{table:t3}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Subject} & $\mathrm{population\_factory}$\\
    {\bf Control} & Manual\\
    {\bf Initial State} & A set of genomes $G$ is available\\
    {\bf Input} & A set of genomes $G$\\
    {\bf Output} & 
    \begin{algorithm}[H]
      \eIf{$\mathrm{type}(G) is \textrm{Set}[Real\rightarrow Real]~\textrm{or} \textrm{type}(G) is \textrm{Set}[(A\rightarrow B)\rightarrow Real]$}{
        do nothing
      }{
        raise error
      }
    \end{algorithm}\\
    
    \bottomrule
  \end{tabularx}
\end{table}

FR2: Interchangeability of evolutionary operators of the same kind
\begin{adjustwidth}{2em}{0pt}
  T4: Each individual selector, variator, and evaluator must pass all test cases for selector, variators, or evaluators respectively.
\end{adjustwidth}



FR 3: Each iteration produces a population
\begin{adjustwidth}{2em}{0pt}
T5: Static validation: each iteration results in a population.
\end{adjustwidth}
FR 4: Subsequent genomes should not have lower fitness.
\begin{adjustwidth}{2em}{0pt}

\begin{table}[!ht]
  \caption{T6: Test Plan for FR4}
  \label{table:t6}
  \begin{tabularx}{\textwidth}{p{3cm}X}
    \toprule
    {\bf Subject} & $\mathrm{System}$\\
    {\bf Control} & Manual\\
    {\bf Initial State} & A population $P$ is available\\
    A variator $V$\\
    A selector $S$\\
    A evaluator $E$\\
    {\bf Input} & A population $P$\\
    {\bf Output} & 
    \begin{algorithm}[H]
      Apply $E$ item-wise to $S(V(P))$. The highest-fitness item in the output $P'$ should have a higher fitness than the highest-fitness item in the previous population $P$.
    \end{algorithm}\\
    
    \bottomrule
  \end{tabularx}
\end{table}
\end{adjustwidth}

\subsection{Non-Functional Requirements}
FR 3: Each iteration produces a population
\begin{adjustwidth}{2em}{0pt}
T5: Static validation: each iteration results in a population.
\end{adjustwidth}

NFR1: Usability
\begin{adjustwidth}{2em}{0pt}
T7: The interface should be inspected and approved by Kelly.
\end{adjustwidth}
NFR 2: Understandability
\begin{adjustwidth}{2em}{0pt}
T8: Design artefacts should be inspected and approved by members of the validation team.
\end{adjustwidth}
NFR 3: Maintainability
\begin{adjustwidth}{2em}{0pt}
T9: Static verification: All functions should use type hints. All argu-ments of all public documents should be documented.
\end{adjustwidth}
NFR 4: Portability
\begin{adjustwidth}{2em}{0pt}
T10: Test cases should pass on a version of Microsoft Windows 11.
\end{adjustwidth}

\subsubsection{Coverage}
Test cases should achieve 100\% function coverage. Record then document statement coverage.

\end{document}